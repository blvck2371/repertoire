name: CD

on:
  push:
    branches: [develop, preprod, prod]

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4

      - name: Définir le tag d'image
        id: tag
        run: |
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "tag=dev" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/preprod" ]; then
            echo "tag=preprod" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/prod" ]; then
            VERSION=$(node -p "require('./package.json').version")
            echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Configurer Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Construction de l'image backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: false
          load: true
          tags: repertoire-backend:${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Construction de l'image frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: false
          load: true
          tags: repertoire-frontend:${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  push-registry:
    runs-on: ubuntu-latest
    needs: build
    if: vars.ENABLE_HARBOR == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Définir le tag d'image
        id: tag
        run: |
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "tag=dev" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/preprod" ]; then
            echo "tag=preprod" >> $GITHUB_OUTPUT
          else
            VERSION=$(node -p "require('./package.json').version")
            echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Configurer le registry
        id: registry
        run: |
          # Plan 1 repo : on utilise un seul dépôt avec des tags backend-* et frontend-*
          REGISTRY_URL="${{ secrets.HARBOR_URL }}"
          REGISTRY_DOMAIN=$(echo "$REGISTRY_URL" | cut -d'/' -f1)
          echo "domain=$REGISTRY_DOMAIN" >> $GITHUB_OUTPUT
          echo "full=$REGISTRY_URL" >> $GITHUB_OUTPUT

      - name: Configurer Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Connexion au registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.domain }}
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      # Plan 1 dépôt : backend et frontend dans le même dépôt avec des tags différents
      - name: Construction et envoi du backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.registry.outputs.full }}/backend:${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Construction et envoi du frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.registry.outputs.full }}/backend:frontend-${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-k8s:
    runs-on: ubuntu-latest
    needs: push-registry
    if: vars.ENABLE_KUBERNETES == 'true' && vars.ENABLE_HARBOR == 'true'
    environment:
      name: ${{ github.ref == 'refs/heads/prod' && 'production' || (github.ref == 'refs/heads/preprod' && 'preprod' || 'development') }}

    steps:
      - uses: actions/checkout@v4

      - name: Définir le namespace et le tag
        id: vars
        run: |
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "namespace=dev" >> $GITHUB_OUTPUT
            echo "tag=dev" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/preprod" ]; then
            echo "namespace=preprod" >> $GITHUB_OUTPUT
            echo "tag=preprod" >> $GITHUB_OUTPUT
          else
            echo "namespace=prod" >> $GITHUB_OUTPUT
            VERSION=$(node -p "require('./package.json').version")
            echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Configurer kubectl
        uses: azure/k8s-set-context@v3
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Créer le secret registry
        run: |
          kubectl create secret docker-registry registry-credentials \
            --docker-server=$(echo "${{ secrets.HARBOR_URL }}" | cut -d'/' -f1) \
            --docker-username=${{ secrets.HARBOR_USERNAME }} \
            --docker-password=${{ secrets.HARBOR_PASSWORD }} \
            --namespace=${{ steps.vars.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Appliquer les manifests
        run: |
          NS=${{ steps.vars.outputs.namespace }}
          REGISTRY="${{ secrets.HARBOR_URL }}"
          TAG=${{ steps.vars.outputs.tag }}
          kubectl apply -f k8s/namespace.yaml
          sed -e "s|REGISTRY_URL|$REGISTRY|g" -e "s|IMAGE_TAG|$TAG|g" k8s/backend-deployment.yaml | kubectl apply -n $NS -f -
          sed -e "s|REGISTRY_URL|$REGISTRY|g" -e "s|IMAGE_TAG|$TAG|g" k8s/frontend-deployment.yaml | kubectl apply -n $NS -f -
          kubectl apply -n $NS -f k8s/mongodb-statefulset.yaml
          echo "✅ Déploiement terminé dans le namespace $NS"

  deploy-droplet:
    runs-on: ubuntu-latest
    needs: build
    if: vars.ENABLE_DROPLET == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Déploiement sur Droplet via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            cd /root/repertoire
            git fetch origin && git reset --hard origin/${{ github.ref_name }}
            COMPOSE_FILES="-f docker-compose.prod.yml"
            [ "${{ vars.ENABLE_VAULT }}" = "true" ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.vault.yml"
            [ "${{ vars.ENABLE_MONITORING }}" = "true" ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.monitoring.yml"
            docker compose $COMPOSE_FILES up -d --build
            docker compose --profile backup -f docker-compose.prod.yml -f docker-compose.backup.yml run --rm backup || true
            docker image prune -f
            echo "✅ Déploiement Droplet terminé"
