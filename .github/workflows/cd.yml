name: CD

on:
  push:
    branches: [develop, preprod, prod]

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4

      - name: Définir le tag d'image
        id: tag
        run: |
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "tag=dev" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/preprod" ]; then
            echo "tag=preprod" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/prod" ]; then
            VERSION=$(node -p "require('./package.json').version")
            echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Configurer Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Construction de l'image backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: false
          load: true
          tags: repertoire-backend:${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Construction de l'image frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: false
          load: true
          tags: repertoire-frontend:${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  push-registry:
    runs-on: ubuntu-latest
    needs: build
    if: vars.ENABLE_HARBOR == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Définir le tag d'image
        id: tag
        run: |
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "tag=dev" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/preprod" ]; then
            echo "tag=preprod" >> $GITHUB_OUTPUT
          else
            VERSION=$(node -p "require('./package.json').version")
            echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Configurer le registry
        id: registry
        run: |
          REGISTRY_URL="${{ secrets.HARBOR_URL }}"
          REGISTRY_URL_CLEAN=$(echo "$REGISTRY_URL" | sed 's|^https\?://||')
          REGISTRY_DOMAIN=$(echo "$REGISTRY_URL_CLEAN" | cut -d'/' -f1)
          echo "domain=$REGISTRY_DOMAIN" >> $GITHUB_OUTPUT
          echo "full=$REGISTRY_URL_CLEAN" >> $GITHUB_OUTPUT

      - name: Configurer le certificat CA Harbor (host + BuildKit)
        if: vars.ENABLE_HARBOR_CA_CERT == 'true'
        run: |
          REGISTRY_DOMAIN="${{ steps.registry.outputs.domain }}"
          CERT_PATH="${{ github.workspace }}/harbor-ca.crt"
          echo "${{ secrets.HARBOR_CA_CERT }}" | base64 -d > "$CERT_PATH"
          # 1. Magasin système (utilisé par certains clients TLS)
          sudo cp "$CERT_PATH" /usr/local/share/ca-certificates/harbor-ca.crt
          sudo update-ca-certificates
          # 2. Docker daemon (pour docker login)
          sudo mkdir -p /etc/docker/certs.d/$REGISTRY_DOMAIN
          sudo cp "$CERT_PATH" /etc/docker/certs.d/$REGISTRY_DOMAIN/ca.crt
          # 3. Redémarrer Docker pour charger le certificat
          sudo systemctl restart docker
          sleep 10
          docker info || true

      - name: Configurer Docker Buildx (insecure pour cert auto-signé Harbor)
        if: vars.ENABLE_HARBOR_CA_CERT == 'true'
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-config-inline: |
            [registry."${{ steps.registry.outputs.domain }}"]
              insecure = true

      - name: Configurer Docker Buildx
        uses: docker/setup-buildx-action@v3
        if: vars.ENABLE_HARBOR_CA_CERT != 'true'

      - name: Connexion au registry
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.registry.outputs.domain }}
          username: ${{ secrets.HARBOR_USERNAME }}
          password: ${{ secrets.HARBOR_PASSWORD }}

      # Plan 1 dépôt : backend et frontend dans le même dépôt avec des tags différents
      - name: Construction et envoi du backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.registry.outputs.full }}/backend:${{ steps.tag.outputs.tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Construction et envoi du frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.registry.outputs.full }}/frontend:${{ steps.tag.outputs.tag }}
          no-cache: true

  deploy-k8s:
    runs-on: ubuntu-latest
    needs: push-registry
    if: vars.ENABLE_KUBERNETES == 'true' && vars.ENABLE_HARBOR == 'true'
    environment:
      name: ${{ github.ref == 'refs/heads/prod' && 'production' || (github.ref == 'refs/heads/preprod' && 'preprod' || 'development') }}

    steps:
      - uses: actions/checkout@v4

      - name: Définir le namespace, tag et domaine
        id: vars
        run: |
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "namespace=dev" >> $GITHUB_OUTPUT
            echo "tag=dev" >> $GITHUB_OUTPUT
            echo "domain=${{ vars.DOMAIN_DEV }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/preprod" ]; then
            echo "namespace=preprod" >> $GITHUB_OUTPUT
            echo "tag=preprod" >> $GITHUB_OUTPUT
            echo "domain=${{ vars.DOMAIN_PREPROD }}" >> $GITHUB_OUTPUT
          else
            echo "namespace=prod" >> $GITHUB_OUTPUT
            VERSION=$(node -p "require('./package.json').version")
            echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
            echo "domain=${{ vars.DOMAIN_PROD }}" >> $GITHUB_OUTPUT
          fi

      - name: Configurer kubectl
        uses: azure/k8s-set-context@v3
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Créer le secret registry
        run: |
          REGISTRY_HOST=$(echo "${{ secrets.HARBOR_URL }}" | sed 's|^https\?://||' | cut -d'/' -f1)
          kubectl create secret docker-registry registry-credentials \
            --docker-server=$REGISTRY_HOST \
            --docker-username=${{ secrets.HARBOR_USERNAME }} \
            --docker-password=${{ secrets.HARBOR_PASSWORD }} \
            --namespace=${{ steps.vars.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Appliquer les manifests
        run: |
          NS=${{ steps.vars.outputs.namespace }}
          REGISTRY="${{ secrets.HARBOR_URL }}"
          TAG=${{ steps.vars.outputs.tag }}
          DOMAIN="${{ steps.vars.outputs.domain }}"
          [ -n "${{ vars.LETSENCRYPT_EMAIL }}" ] && sed -e "s|LETSENCRYPT_EMAIL|${{ vars.LETSENCRYPT_EMAIL }}|g" k8s/cert-manager-issuer.yaml | kubectl apply -f - || true
          kubectl apply -f k8s/namespace.yaml
          sed -e "s|REGISTRY_URL|$REGISTRY|g" -e "s|IMAGE_TAG|$TAG|g" k8s/backend-deployment.yaml | kubectl apply -n $NS -f -
          sed -e "s|REGISTRY_URL|$REGISTRY|g" -e "s|IMAGE_TAG|$TAG|g" k8s/frontend-deployment.yaml | kubectl apply -n $NS -f -
          kubectl apply -n $NS -f k8s/mongodb-statefulset.yaml
          kubectl apply -n $NS -f k8s/hpa.yaml
          if [ "${{ vars.ENABLE_K8S_INGRESS }}" = "true" ]; then
            if [ -n "$DOMAIN" ]; then
              sed -e "s|DOMAIN_HOST|$DOMAIN|g" k8s/frontend-service-clusterip.yaml | kubectl apply -n $NS -f -
              sed -e "s|DOMAIN_HOST|$DOMAIN|g" k8s/ingress-traefik-tls.yaml | kubectl apply -n $NS -f -
            else
              kubectl apply -n $NS -f k8s/ingress-traefik.yaml
            fi
          fi
          echo "✅ Déploiement terminé dans le namespace $NS"

  # Déploiement Droplet : uniquement pour develop (preprod/prod → Kubernetes)
  deploy-droplet:
    runs-on: ubuntu-latest
    needs: build
    if: vars.ENABLE_DROPLET == 'true' && github.ref == 'refs/heads/develop'
    steps:
      - uses: actions/checkout@v4

      - name: Déploiement sur Droplet (build sur serveur)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_IP }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          script: |
            set -e
            cd /root/repertoire
            git fetch origin && git reset --hard origin/${{ github.ref_name }}
            COMPOSE_FILES="-f docker-compose.prod.yml"
            [ "${{ vars.ENABLE_VAULT }}" = "true" ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.vault.yml"
            [ "${{ vars.ENABLE_MONITORING }}" = "true" ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.monitoring.yml"
            [ "${{ vars.ENABLE_HTTPS }}" = "true" ] && COMPOSE_FILES="$COMPOSE_FILES -f docker-compose.https.yml"
            export $(grep -v '^#' .env | xargs) 2>/dev/null || true
            docker compose $COMPOSE_FILES build --no-cache
            docker compose $COMPOSE_FILES up -d --force-recreate
            docker compose -f docker-compose.prod.yml -f docker-compose.backup.yml --profile backup run --rm --build backup || true
            docker image prune -f
            echo "✅ Déploiement Droplet terminé"

